use std::os::unix::net::UnixStream;
use std::env;
use std::io::prelude::*;
//use std::fmt;
use std::path::Path;
use std::io::BufReader;
use std::collections::HashMap;
use std::process::Command;

use serde::{Serialize, Deserialize};
use serde_json::Value;

    struct All {
    active_win: String,
    active_work: u8,
    workspaces: HashMap<u8, String>//[u8; 128]
}


impl All {
    fn describe(&self) {
       let mut entries: Vec<_> = self.workspaces.iter().collect();
entries.sort_by_key(|&(id, _)| id);
let output = entries.into_iter()
    .map(|(id, name)| format!("{{\"id\":\"{}\",\"name\":\"{}\"}}", id, name))
    .collect::<Vec<_>>()
    .join(", ");   
    
  println!("{{\"activewindow\":\"{}\",\"workspace\":\"{}\",\"workspaces\":[{}]}}"
  , self.active_win
  , self.active_work 
  ,output// self.workspaces.iter().map(|(i, v)| format!("{{\"id\":\"{}\",\"name\":\"{}\"}}", i, v)).collect::<Vec<_>>().join(", ")


);  
    
}
}



fn main() {
   //hyprvars();
   readsock2(Path::new(&env::var_os("XDG_RUNTIME_DIR").unwrap())
   .join("hypr")
   .join(env::var_os("HYPRLAND_INSTANCE_SIGNATURE").unwrap())
    .join(".socket2.sock")).ok();
}



    fn hyprvars() -> Result<(), Box<dyn std::error::Error>> 
    {

        let workspaces_output = Command::new("hyprctl")
    .args(["workspaces","-j"])
    .output()
    .expect("Failed to execute acw");
    let workspaces: Vec<Value> = serde_json::from_slice(&workspaces_output.stdout)?; 
   
let mut workspace_map: HashMap<u32, String> = HashMap::new();

for ws in &workspaces {
    if let Some(id) = ws.get("id").and_then(|v| v.as_u64()).map(|v| v as u32) {
       if let Some(name) = ws.get("name").and_then(|v| v.as_str()) {
        workspace_map.insert(id, name.to_string() ); }
}
}

for (k,v) in &workspace_map { 
 println! ("{{id:\"{}\",name:\"{}\"}}", k,v )   };
  
Ok(())
    }



fn readsock2 <P: AsRef<Path>>(socket_path: P) -> Result<(), Box<dyn std::error::Error>> {
    
    let stream = UnixStream::connect(socket_path)?;
    let reader = BufReader::new(&stream);
    

//for (id, name) in self.workspace.iter().enumerate()
//iter gets values of indexs
//enum gives them index value
//maps varibles and uses them in function map(|input|output)
//put result for each enum and iter into vector
//join vecs with ,
//print result of all vecs with println
   
let mut my_struct = All  { active_win: "No Window".to_string(), active_work: 0, workspaces:HashMap::from([
    (3, "foo".to_string()),
   
]) };

 let workspaces_output = Command::new("hyprctl")
    .args(["workspaces","-j"])
    .output()
    .expect("Failed to execute acw");
    let workspaces: Vec<Value> = serde_json::from_slice(&workspaces_output.stdout)?; 

for ws in &workspaces {
    if let Some(id) = ws.get("id").and_then(|v| v.as_u64()).map(|v| v as u8) {
       if let Some(name) = ws.get("name").and_then(|v| v.as_str()) {
        my_struct.workspaces.insert(id, name.to_string() ); }
}
}

   for line_result in reader.lines() {
    let line = line_result?;
   if let Some(stripped) = line.strip_prefix("activewindow>>") {
    my_struct.active_win = stripped.to_string();
    my_struct.describe(); }
    
    else if let Some(stripped) = line.strip_prefix("workspace>>") {
    my_struct.active_work = stripped.parse::<u8>()?;
    my_struct.describe();
    }

    else if let Some(stripped) = line.strip_prefix("createworkspacev2>>") {
    let (name, id) = stripped.split_once(',').expect("missing comma");
    my_struct.workspaces.insert(id.parse::<u8>()?,name.to_string());
    my_struct.describe();
    }
 
    else if let Some(stripped) = line.strip_prefix("destroyworkspacev2>>") {
    let (name, id) = stripped.split_once(',').expect("missing comma");
    my_struct.workspaces.remove(&id.parse::<u8>()?);
    my_struct.describe();
    }
    
}
Ok(())
}
   





